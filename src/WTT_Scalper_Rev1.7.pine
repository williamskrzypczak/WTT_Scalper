//@version=5
indicator("WTT Scalper Rev1.7", shorttitle="WTT_Scalper_R1.7", overlay=true)

// =============================================================================
// WaveRider Trading Technologies - Keltner Channel Trading System
// =============================================================================
//
// REVISION HISTORY (Most Recent First):
// R1.7: Performance Tracking Implementation and System Optimization - Added signal-based performance tracking
//       with success rate and ratio metrics. Implemented proper success measurement for profit targets and
//       trailing stops. Enhanced performance display table with comprehensive success metrics. Optimized
//       trailing stop functionality with red dot visualization and proper reset logic. Improved squeeze
//       cloud visibility with darker purple fill. Streamlined code structure and removed unnecessary
//       complexity. Added comprehensive performance metrics for trading analysis and system evaluation.
// R1.6: Enhanced Alert Precision and Visual Improvements - Increased alert price precision to 5 decimal places
//       for all signal types. Optimized code structure with functions for better maintainability.
//       Added squeeze cloud visualization with purple fill and orange boundary lines. Improved signal
//       visibility with small triangles and dotted vertical lines. Enhanced color scheme consistency
//       with WTT branding. Maintains all core functionality while providing better visual feedback
//       and more precise alert information.
// R1.5: Simplified Performance Table - Streamlined performance table to show only essential metrics
//       Removed total trades row and reduced table to 3 rows: header, win rate, and squeeze status.
//       Changed squeeze indicator squares from yellow to orange for better WTT branding consistency.
//       Maintains all core functionality while providing cleaner, more focused performance display.
// R1.4: Trailing Stop Enhancement - Added trailing stop functionality that activates when price reaches 50% of profit target
//       Implemented trailing stop with ATR-based distance that locks in profits while allowing for continued upside.
//       Added visual indicators for trailing stop levels and enhanced risk management for better trade management.
//       Maintains all core functionality while providing dynamic exit management for improved profitability.
// R1.3: Squeeze-only Strategy - Converted to squeeze release signals only for higher quality entries
//       Removed traditional breakout signals, keeping only squeeze release entries. Changed visual
//       signals from circles to directional triangles for better clarity. Updated alerts to reflect
//       squeeze-only approach. Maintains all core functionality while focusing on volatility expansion
//       opportunities for improved signal quality and reduced noise.
// R1.2: Simplified Interface - Removed unnecessary input controls for cleaner user experience
//       Removed enable_long/enable_short inputs and hardcoded to true. Removed trend filter
//       inputs and hardcoded to 50-period EMA. Removed unused inputs and streamlined alerts.
//       Streamlined interface while maintaining all core functionality.
// R1.1: Fixed Plot Issues - Resolved "Undeclared identifier 'plot'" error
//       Simplified plot statements and improved code structure for better
//       Pine Script v5 compatibility. Maintained all functionality while
//       fixing parsing issues that prevented proper compilation.
// R1.0: Initial Release - Comprehensive Keltner Channel Trading System
//       Advanced Keltner Channel implementation with multiple timeframe support,
//       conservative entry/exit signals, comprehensive risk management, and
//       detailed performance tracking. Features include breakout detection,
//       squeeze identification, trend filtering, and dynamic stop loss/profit
//       target calculations. Designed for conservative trading approach with
//       multiple confirmation filters and comprehensive alert system.
//
// =============================================================================
// FEATURES:
// - Single-timeframe Keltner Channel analysis (simplified for reliability)
// - Squeeze release entry signals with volume confirmation
// - Squeeze detection and expansion alerts
// - Trend filtering with 50-period EMA (hardcoded)
// - Dynamic ATR-based stop loss and profit targets
// - Comprehensive performance tracking
// - Visual trade signals (circles for squeeze releases only)
// - Streamlined alert system for key trading conditions
// - Risk management with ATR-based position sizing
// - Success rate and drawdown monitoring
// - Subtle squeeze indicators (tiny yellow squares)
// - Trailing stop functionality with 50% profit target activation
// =============================================================================

// INPUT SECTION
scalp_length = input.int(20, title="Channel Length", minval=1, group="Scalp Channel")
scalp_multiplier = input.float(2.0, title="Channel Multiplier", minval=0.1, step=0.1, group="Scalp Channel")
scalp_ma_type = input.string("EMA", title="MA Type", options=["SMA", "EMA", "WMA", "HMA"], group="Scalp Channel")
scalp_source = input.source(close, title="Source", group="Scalp Channel")

// Multi-timeframe inputs removed for simplicity

enable_volume_filter = input.bool(true, title="Volume Filter", tooltip="Require above average volume for signals", group="Trading")
volume_ma_length = input.int(20, title="Volume MA Length", minval=1, group="Trading")



atr_length = input.int(14, title="ATR Length", minval=1, group="Risk Management")
stop_loss_multiplier = input.float(1.5, title="Stop Loss ATR Multiplier", minval=0.1, step=0.1, group="Risk Management")
profit_target_multiplier = input.float(2.5, title="Profit Target ATR Multiplier", minval=0.1, step=0.1, group="Risk Management")
trailing_stop_multiplier = input.float(1.0, title="Trailing Stop ATR Multiplier", minval=0.1, step=0.1, group="Risk Management")
risk_percent = input.float(2.0, title="Risk Per Trade (%)", minval=0.1, maxval=10.0, step=0.1, group="Risk Management")

enable_squeeze = input.bool(true, title="Enable Squeeze Detection", group="Squeeze")
bb_length = input.int(20, title="Bollinger Bands Length", minval=1, group="Squeeze")
bb_multiplier = input.float(2.0, title="BB Multiplier", minval=0.1, step=0.1, group="Squeeze")

show_kc_bands = input.bool(false, title="Show KC Bands", group="Visual")
show_trend_ma = input.bool(false, title="Show Trend MA", group="Visual")
show_signals = input.bool(true, title="Show Trade Signals", group="Visual")


// FUNCTION DEFINITIONS
// Moving Average Function
ma_function(src, length, ma_type) =>
    switch ma_type
        "SMA" => ta.sma(src, length)
        "EMA" => ta.ema(src, length)
        "WMA" => ta.wma(src, length)
        "HMA" => ta.hma(src, length)
        => ta.ema(src, length)

// Signal Generation Function
generate_signal(is_long, squeeze_release, kc_ma, is_trend, volume_filter) =>
    if is_long
        squeeze_release and close > kc_ma and is_trend and volume_filter
    else
        squeeze_release and close < kc_ma and is_trend and volume_filter



// Exit Condition Function
check_exit_conditions(is_long, kc_ma, kc_upper, kc_lower, stop_loss, profit_target, trailing_active, trailing_stop) =>
    if is_long
        close < kc_ma or close < kc_lower or close <= stop_loss or close >= profit_target or (trailing_active and close <= trailing_stop)
    else
        close > kc_ma or close > kc_upper or close >= stop_loss or close <= profit_target or (trailing_active and close >= trailing_stop)



// Alert Function
generate_alert(condition, message) =>
    if condition
        alert(message, alert.freq_once_per_bar)

// CALCULATION SECTION
kc_ma = ma_function(scalp_source, scalp_length, scalp_ma_type)
kc_range = ta.atr(scalp_length) * scalp_multiplier
kc_upper = kc_ma + kc_range
kc_lower = kc_ma - kc_range

trend_ma = ta.ema(close, 50)
is_uptrend = close > trend_ma
is_downtrend = close < trend_ma

volume_ma = ta.sma(volume, volume_ma_length)
volume_filter_long = enable_volume_filter ? volume > volume_ma : true
volume_filter_short = enable_volume_filter ? volume > volume_ma : true

atr_value = ta.atr(atr_length)

bb_basis = ta.sma(close, bb_length)
bb_dev = bb_multiplier * ta.stdev(close, bb_length)
bb_upper = bb_basis + bb_dev
bb_lower = bb_basis - bb_dev
is_squeeze = bb_upper < kc_upper and bb_lower > kc_lower
squeeze_release = is_squeeze[1] and not is_squeeze

// TRADING LOGIC
long_signal_enhanced = generate_signal(true, squeeze_release, kc_ma, is_uptrend, volume_filter_long)
short_signal_enhanced = generate_signal(false, squeeze_release, kc_ma, is_downtrend, volume_filter_short)

// Risk Management Variables
var float long_stop_loss = na
var float long_profit_target = na
var float short_stop_loss = na
var float short_profit_target = na
var float long_trailing_stop = na
var float short_trailing_stop = na
var bool long_trailing_active = false
var bool short_trailing_active = false

// Calculate risk levels when signals occur
if long_signal_enhanced
    long_stop_loss := close - (atr_value * stop_loss_multiplier)
    long_profit_target := close + (atr_value * profit_target_multiplier)
    long_trailing_active := false
    long_trailing_stop := na

if short_signal_enhanced
    short_stop_loss := close + (atr_value * stop_loss_multiplier)
    short_profit_target := close - (atr_value * profit_target_multiplier)
    short_trailing_active := false
    short_trailing_stop := na

// Position Management
var bool in_long_position = false
var bool in_short_position = false
var float entry_price = na
var int bars_in_trade = 0

if long_signal_enhanced and not in_long_position and not in_short_position
    in_long_position := true
    in_short_position := false
    entry_price := close
    bars_in_trade := 0

if short_signal_enhanced and not in_short_position and not in_long_position
    in_short_position := true
    in_long_position := false
    entry_price := close
    bars_in_trade := 0

if in_long_position or in_short_position
    bars_in_trade += 1

// Trailing Stop Logic
if in_long_position and close >= long_profit_target * 0.5 and not long_trailing_active
    long_trailing_active := true
    long_trailing_stop := close - (atr_value * trailing_stop_multiplier)

if in_short_position and close <= short_profit_target * 0.5 and not short_trailing_active
    short_trailing_active := true
    short_trailing_stop := close + (atr_value * trailing_stop_multiplier)

if long_trailing_active and not na(long_trailing_stop[1])
    long_trailing_stop := math.max(long_trailing_stop[1], close - (atr_value * trailing_stop_multiplier))

if short_trailing_active and not na(short_trailing_stop[1])
    short_trailing_stop := math.min(short_trailing_stop[1], close + (atr_value * trailing_stop_multiplier))

// Reset trailing stop when new signal fires
if long_signal_enhanced or short_signal_enhanced
    long_trailing_active := false
    short_trailing_active := false
    long_trailing_stop := na
    short_trailing_stop := na

// Exit Conditions
long_exit = check_exit_conditions(true, kc_ma, kc_upper, kc_lower, long_stop_loss, long_profit_target, long_trailing_active, long_trailing_stop)
short_exit = check_exit_conditions(false, kc_ma, kc_upper, kc_lower, short_stop_loss, short_profit_target, short_trailing_active, short_trailing_stop)

if long_exit
    in_long_position := false
    entry_price := na
    long_trailing_active := false
    long_trailing_stop := na

if short_exit
    in_short_position := false
    entry_price := na
    short_trailing_active := false
    short_trailing_stop := na

// PERFORMANCE TRACKING
var int total_signals = 0
var int profitable_trades = 0

// Count signals when they fire
if long_signal_enhanced or short_signal_enhanced
    total_signals += 1

// Track profitable exits (profit target or trailing stop)
if (in_long_position[1] and not in_long_position) or (in_short_position[1] and not in_short_position)
    // Check if exit was profitable (profit target or trailing stop)
    long_profitable = in_long_position[1] and not in_long_position and (close >= long_profit_target[1] or (long_trailing_active[1] and close <= long_trailing_stop[1]))
    short_profitable = in_short_position[1] and not in_short_position and (close <= short_profit_target[1] or (short_trailing_active[1] and close >= short_trailing_stop[1]))
    
    if long_profitable or short_profitable
        profitable_trades += 1

// Calculate success metrics
success_rate = total_signals > 0 ? (profitable_trades / total_signals) * 100 : 0
success_ratio = total_signals > 0 ? str.tostring(profitable_trades) + ":" + str.tostring(total_signals - profitable_trades) : "0:0"

// Calculate current risk-to-reward ratio
risk_reward_ratio = profit_target_multiplier / stop_loss_multiplier



// PLOTTING SECTION
orange_color = color.new(color.orange, 50)
purple_color = color.new(color.purple, 30)
fill_color = color.new(color.orange, 90)

upper_line = plot(show_kc_bands ? kc_upper : na, "Scalp Upper", orange_color, 2)
lower_line = plot(show_kc_bands ? kc_lower : na, "Scalp Lower", orange_color, 2)
middle_line = plot(show_kc_bands ? kc_ma : na, "Scalp Middle", purple_color, 1)

fill(upper_line, lower_line, fill_color)

plot(show_trend_ma ? trend_ma : na, "Trend MA", color.purple, 2)

// Plot signals
plotshape(show_signals and long_signal_enhanced, "Long Squeeze", shape.triangleup, location.belowbar, color.orange, size=size.small)
plotshape(show_signals and short_signal_enhanced, "Short Squeeze", shape.triangledown, location.abovebar, color.purple, size=size.small)

// Vertical lines through signal bars
if show_signals and long_signal_enhanced
    line.new(bar_index, low, bar_index, high, color=color.orange, width=1, extend=extend.both, style=line.style_dotted)
if show_signals and short_signal_enhanced
    line.new(bar_index, low, bar_index, high, color=color.new(#800080, 0), width=1, extend=extend.both, style=line.style_dotted)

// SQUEEZE CLOUD
squeeze_upper = plot(is_squeeze ? high + (atr_value * 0.5) : na, "Squeeze Upper", color.new(color.purple, 40), 1)
squeeze_lower = plot(is_squeeze ? low - (atr_value * 0.5) : na, "Squeeze Lower", color.new(color.purple, 40), 1)
fill(squeeze_upper, squeeze_lower, color=color.new(color.purple, 50), title="Squeeze Cloud")

// Plot risk management levels
long_sl_show = in_long_position ? long_stop_loss : na
long_tp_show = in_long_position ? long_profit_target : na
long_ts_show = in_long_position and long_trailing_active ? long_trailing_stop : na
short_sl_show = in_short_position ? short_stop_loss : na
short_tp_show = in_short_position ? short_profit_target : na
short_ts_show = in_short_position and short_trailing_active ? short_trailing_stop : na

plot(long_sl_show, "Long SL", color.orange, 1, plot.style_circles)
plot(long_tp_show, "Long TP", color.green, 1, plot.style_circles)
plot(long_ts_show, "Long Trailing Stop", color.red, 1, plot.style_circles)
plot(short_sl_show, "Short SL", color.purple, 1, plot.style_circles)
plot(short_tp_show, "Short TP", color.green, 1, plot.style_circles)
plot(short_ts_show, "Short Trailing Stop", color.red, 1, plot.style_circles)

// PERFORMANCE DISPLAY
if barstate.islast
    var table perf_table = table.new(position.top_right, 2, 5, bgcolor=color.new(color.black, 10), border_width=2, border_color=color.orange)
    table.cell(perf_table, 0, 0, "WTT Scalper Performance", text_color=color.white, text_size=size.normal, bgcolor=color.orange)
    table.cell(perf_table, 1, 0, "", bgcolor=color.orange)
    table.cell(perf_table, 0, 1, "Success Rate", text_color=color.white, text_size=size.small, bgcolor=color.new(color.black, 0))
    table.cell(perf_table, 1, 1, str.tostring(success_rate, "#.#") + "%", text_color=color.lime, text_size=size.small, bgcolor=color.new(color.black, 20))
    table.cell(perf_table, 0, 2, "Success Ratio", text_color=color.white, text_size=size.small, bgcolor=color.new(color.black, 0))
    table.cell(perf_table, 1, 2, success_ratio + " (W:L)", text_color=color.lime, text_size=size.small, bgcolor=color.new(color.black, 20))
    table.cell(perf_table, 0, 3, "Risk:Reward", text_color=color.white, text_size=size.small, bgcolor=color.new(color.black, 0))
    table.cell(perf_table, 1, 3, "1:" + str.tostring(risk_reward_ratio, "#.##"), text_color=color.yellow, text_size=size.small, bgcolor=color.new(color.black, 20))
    table.cell(perf_table, 0, 4, "Total Signals", text_color=color.white, text_size=size.small, bgcolor=color.new(color.black, 0))
    table.cell(perf_table, 1, 4, str.tostring(total_signals), text_color=color.white, text_size=size.small, bgcolor=color.new(color.black, 20))



// ALERTS using function
generate_alert(long_signal_enhanced, "WTT Scalper: " + syminfo.ticker + " LONG signal at " + str.tostring(close, "#.#####") + " | Check levels on chart")
generate_alert(short_signal_enhanced, "WTT Scalper: " + syminfo.ticker + " SHORT signal at " + str.tostring(close, "#.#####") + " | Check levels on chart")
generate_alert(is_squeeze and not is_squeeze[1], "WTT Scalper: " + syminfo.ticker + " SQUEEZE detected at " + str.tostring(close, "#.#####") + " - Low volatility period, prepare for breakout")
generate_alert(squeeze_release, "WTT Scalper: " + syminfo.ticker + " SQUEEZE RELEASE at " + str.tostring(close, "#.#####") + " - Volatility expansion beginning")
generate_alert(long_trailing_active and not long_trailing_active[1], "WTT Scalper: " + syminfo.ticker + " TRAILING STOP ACTIVATED for LONG position at " + str.tostring(close, "#.#####"))
generate_alert(short_trailing_active and not short_trailing_active[1], "WTT Scalper: " + syminfo.ticker + " TRAILING STOP ACTIVATED for SHORT position at " + str.tostring(close, "#.#####"))
generate_alert(long_trailing_active, "WTT Scalper: " + syminfo.ticker + " LONG Trailing Stop Level: " + str.tostring(long_trailing_stop, "#.#####"))
generate_alert(short_trailing_active, "WTT Scalper: " + syminfo.ticker + " SHORT Trailing Stop Level: " + str.tostring(short_trailing_stop, "#.#####"))
